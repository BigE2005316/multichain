// commands/AdminCommand.js - Fixed Admin Command Implementation
const userService = require('../users/userService');

class AdminCommand {
  constructor(botCore) {
    this.botCore = botCore;
  }

  register() {
    // Main admin command
    this.botCore.registerCommand('admin', async (ctx) => {
      if (!this.isAdmin(ctx.from.id)) {
        return ctx.reply('‚ùå Unauthorized: Admin access required');
      }

      await this.showAdminDashboard(ctx);
    });

    // Admin subcommands
    this.botCore.registerCommand('setfee', async (ctx) => {
      if (!this.isAdmin(ctx.from.id)) {
        return ctx.reply('‚ùå Unauthorized: Admin access required');
      }

      await this.handleSetFee(ctx);
    });

    this.botCore.registerCommand('stats', async (ctx) => {
      if (!this.isAdmin(ctx.from.id)) {
        return ctx.reply('‚ùå Unauthorized: Admin access required');
      }

      await this.showGlobalStats(ctx);
    });

    this.botCore.registerCommand('users', async (ctx) => {
      if (!this.isAdmin(ctx.from.id)) {
        return ctx.reply('‚ùå Unauthorized: Admin access required');
      }

      await this.showUserStats(ctx);
    });

    this.botCore.registerCommand('health', async (ctx) => {
      if (!this.isAdmin(ctx.from.id)) {
        return ctx.reply('‚ùå Unauthorized: Admin access required');
      }

      await this.showSystemHealth(ctx);
    });

    this.botCore.registerCommand('broadcast', async (ctx) => {
      if (!this.isAdmin(ctx.from.id)) {
        return ctx.reply('‚ùå Unauthorized: Admin access required');
      }

      await this.handleBroadcast(ctx);
    });
  }

  isAdmin(userId) {
    const adminId = process.env.ADMIN_TELEGRAM_ID || process.env.ADMIN_ID;
    return adminId && String(userId) === String(adminId);
  }

  async showAdminDashboard(ctx) {
    try {
      const loadingMsg = await ctx.reply('üîß Loading admin dashboard...');

      // Get basic stats safely
      let userStats = {
        totalUsers: 0,
        activeUsers24h: 0,
        newUsersToday: 0,
        totalTrades: 0,
        totalVolume: 0,
        successRate: 'N/A'
      };

      try {
        userStats = await this.getBasicStats();
      } catch (error) {
        console.log('Could not get user stats:', error.message);
      }

      let dashboard = `üîß **Admin Dashboard** - Smile Snipper Bot\n\n`;
      
      // System Status
      dashboard += `üìä **System Status**\n`;
      dashboard += `‚Ä¢ Uptime: ${Math.floor(process.uptime() / 3600)}h ${Math.floor((process.uptime() % 3600) / 60)}m\n`;
      dashboard += `‚Ä¢ Memory: ${Math.round(process.memoryUsage().heapUsed / 1024 / 1024)}MB\n`;
      dashboard += `‚Ä¢ Bot Status: ‚úÖ Online\n`;
      dashboard += `‚Ä¢ Current Time: ${new Date().toLocaleString()}\n\n`;
      
      // User Stats
      dashboard += `üë• **User Statistics**\n`;
      dashboard += `‚Ä¢ Total Users: ${userStats.totalUsers}\n`;
      dashboard += `‚Ä¢ Active (24h): ${userStats.activeUsers24h}\n`;
      dashboard += `‚Ä¢ New Today: ${userStats.newUsersToday}\n\n`;
      
      // Trading Stats
      dashboard += `üí∞ **Trading Statistics**\n`;
      dashboard += `‚Ä¢ Total Trades: ${userStats.totalTrades}\n`;
      dashboard += `‚Ä¢ Total Volume: $${userStats.totalVolume?.toLocaleString() || '0'}\n`;
      dashboard += `‚Ä¢ Success Rate: ${userStats.successRate}\n`;
      dashboard += `‚Ä¢ Dev Fee: ${process.env.DEV_FEE_PERCENT || 3}%\n\n`;
      
      // Environment Info
      dashboard += `‚öôÔ∏è **Configuration**\n`;
      dashboard += `‚Ä¢ Node Version: ${process.version}\n`;
      dashboard += `‚Ä¢ Environment: ${process.env.NODE_ENV || 'development'}\n`;
      dashboard += `‚Ä¢ Admin ID: ${process.env.ADMIN_TELEGRAM_ID ? '‚úÖ Set' : '‚ùå Missing'}\n\n`;
      
      dashboard += `üõ†Ô∏è **Admin Commands**\n`;
      dashboard += `‚Ä¢ /setfee <percent> - Set trading fee\n`;
      dashboard += `‚Ä¢ /stats - Detailed statistics\n`;
      dashboard += `‚Ä¢ /users - User analytics\n`;
      dashboard += `‚Ä¢ /health - System health check\n`;
      dashboard += `‚Ä¢ /broadcast <msg> - Message all users\n`;
      dashboard += `‚Ä¢ /viewfees - View collected fees\n\n`;
      
      dashboard += `üéØ **Quick Actions**\n`;
      dashboard += `‚Ä¢ Current Fee: ${process.env.DEV_FEE_PERCENT || 3}%\n`;
      dashboard += `‚Ä¢ Bot Running Time: ${Math.floor(process.uptime() / 60)} minutes\n`;

      await ctx.telegram.editMessageText(
        ctx.chat.id, loadingMsg.message_id, undefined,
        dashboard, { parse_mode: 'Markdown' }
      );

    } catch (error) {
      console.error('Admin dashboard error:', error);
      await ctx.reply(`‚ùå Admin dashboard error: ${error.message}`);
    }
  }

  async getBasicStats() {
    try {
      const allUsers = await userService.getAllUsers();
      const now = Date.now();
      const oneDayAgo = now - 24 * 60 * 60 * 1000;
      
      return {
        totalUsers: allUsers.length,
        activeUsers24h: allUsers.filter(u => (u.lastActive || 0) > oneDayAgo).length,
        newUsersToday: allUsers.filter(u => (u.createdAt || 0) > oneDayAgo).length,
        totalTrades: 0, // This would come from trading history
        totalVolume: 0, // This would come from trading history
        successRate: 'N/A'
      };
    } catch (error) {
      return {
        totalUsers: 0,
        activeUsers24h: 0,
        newUsersToday: 0,
        totalTrades: 0,
        totalVolume: 0,
        successRate: 'N/A'
      };
    }
  }

  async handleSetFee(ctx) {
    const args = ctx.message.text.split(' ').slice(1);
    
    if (args.length < 1) {
      return ctx.reply(`üìù **Set Trading Fee**

**Usage:** \`/setfee <percent>\`

**Example:** \`/setfee 3\`

**Current Fee:** ${process.env.DEV_FEE_PERCENT || 3}%

**Valid Range:** 0% - 10%`, 
        { parse_mode: 'Markdown' });
    }

    const feePercent = parseFloat(args[0]);
    
    if (isNaN(feePercent) || feePercent < 0 || feePercent > 10) {
      return ctx.reply('‚ùå Invalid fee percentage. Must be between 0% and 10%.');
    }

    try {
      // Update environment variable
      process.env.DEV_FEE_PERCENT = String(feePercent);
      
      await ctx.reply(`‚úÖ **Trading fee updated successfully!**

**New Fee:** ${feePercent}%
**Previous Fee:** ${process.env.DEV_FEE_PERCENT || 3}%

This applies to all new trades immediately.`, 
        { parse_mode: 'Markdown' });

    } catch (error) {
      console.error('Set fee error:', error);
      await ctx.reply(`‚ùå Error setting fee: ${error.message}`);
    }
  }

  async showGlobalStats(ctx) {
    try {
      const loadingMsg = await ctx.reply('üìä Generating global statistics...');
      
      const stats = await this.getBasicStats();
      
      let message = `üìä **Global Statistics Report**\n\n`;
      
      message += `üë• **User Metrics**\n`;
      message += `‚Ä¢ Total Users: ${stats.totalUsers}\n`;
      message += `‚Ä¢ Active (24h): ${stats.activeUsers24h}\n`;
      message += `‚Ä¢ New Today: ${stats.newUsersToday}\n`;
      message += `‚Ä¢ Growth Rate: ${stats.totalUsers > 0 ? ((stats.newUsersToday / stats.totalUsers) * 100).toFixed(1) : 0}%\n\n`;
      
      message += `üí∞ **Trading Metrics**\n`;
      message += `‚Ä¢ Total Trades: ${stats.totalTrades}\n`;
      message += `‚Ä¢ Total Volume: $${stats.totalVolume?.toLocaleString() || '0'}\n`;
      message += `‚Ä¢ Success Rate: ${stats.successRate}\n`;
      message += `‚Ä¢ Average per User: ${stats.totalUsers > 0 ? (stats.totalTrades / stats.totalUsers).toFixed(1) : 0} trades\n\n`;
      
      message += `üí∏ **Revenue Metrics**\n`;
      message += `‚Ä¢ Current Fee Rate: ${process.env.DEV_FEE_PERCENT || 3}%\n`;
      message += `‚Ä¢ Estimated Fees: $${((stats.totalVolume || 0) * 0.03).toFixed(2)}\n\n`;
      
      message += `‚öôÔ∏è **System Metrics**\n`;
      message += `‚Ä¢ Uptime: ${Math.floor(process.uptime() / 3600)}h ${Math.floor((process.uptime() % 3600) / 60)}m\n`;
      message += `‚Ä¢ Memory Usage: ${Math.round(process.memoryUsage().heapUsed / 1024 / 1024)}MB\n`;
      message += `‚Ä¢ Bot Version: 2.0.0 Professional\n\n`;
      
      message += `üïí **Generated:** ${new Date().toLocaleString()}`;

      await ctx.telegram.editMessageText(
        ctx.chat.id, loadingMsg.message_id, undefined,
        message, { parse_mode: 'Markdown' }
      );

    } catch (error) {
      console.error('Global stats error:', error);
      await ctx.reply('‚ùå Failed to generate global statistics');
    }
  }

  async showUserStats(ctx) {
    try {
      const loadingMsg = await ctx.reply('üë• Generating user analytics...');
      
      const users = await userService.getAllUsers();
      
      // Calculate user statistics
      const now = Date.now();
      const oneDayAgo = now - 24 * 60 * 60 * 1000;
      const oneWeekAgo = now - 7 * 24 * 60 * 60 * 1000;
      
      const activeToday = users.filter(u => (u.lastActive || 0) > oneDayAgo).length;
      const activeWeek = users.filter(u => (u.lastActive || 0) > oneWeekAgo).length;
      const newToday = users.filter(u => (u.createdAt || 0) > oneDayAgo).length;
      
      // Top users by activity
      const topUsers = users
        .filter(u => u.lastActive)
        .sort((a, b) => b.lastActive - a.lastActive)
        .slice(0, 10);

      let message = `üë• **User Analytics Report**\n\n`;
      
      message += `üìä **Overview**\n`;
      message += `‚Ä¢ Total Users: ${users.length}\n`;
      message += `‚Ä¢ Active Today: ${activeToday}\n`;
      message += `‚Ä¢ Active This Week: ${activeWeek}\n`;
      message += `‚Ä¢ New Today: ${newToday}\n`;
      message += `‚Ä¢ Retention Rate: ${users.length > 0 ? ((activeWeek / users.length) * 100).toFixed(1) : 0}%\n\n`;
      
      message += `üèÜ **Most Recent Active Users**\n`;
      if (topUsers.length > 0) {
        topUsers.slice(0, 5).forEach((user, index) => {
          const lastActive = user.lastActive ? new Date(user.lastActive).toLocaleDateString() : 'Never';
          const username = user.username || `User${user.id}`;
          message += `${index + 1}. @${username} - ${lastActive}\n`;
        });
      } else {
        message += `No active users found\n`;
      }
      
      message += `\nüìà **User Distribution**\n`;
      message += `‚Ä¢ Very Active (< 1 day): ${activeToday}\n`;
      message += `‚Ä¢ Active (< 7 days): ${activeWeek - activeToday}\n`;
      message += `‚Ä¢ Inactive (> 7 days): ${users.length - activeWeek}\n\n`;
      
      message += `üïí **Generated:** ${new Date().toLocaleString()}`;

      await ctx.telegram.editMessageText(
        ctx.chat.id, loadingMsg.message_id, undefined,
        message, { parse_mode: 'Markdown' }
      );

    } catch (error) {
      console.error('User stats error:', error);
      await ctx.reply('‚ùå Failed to get user statistics');
    }
  }

  async showSystemHealth(ctx) {
    try {
      const loadingMsg = await ctx.reply('üè• Running system health check...');
      
      let message = `üè• **System Health Report**\n\n`;
      
      // Basic system health
      message += `üíæ **System Resources**\n`;
      const memUsage = process.memoryUsage();
      message += `‚Ä¢ Memory Used: ${Math.round(memUsage.heapUsed / 1024 / 1024)}MB\n`;
      message += `‚Ä¢ Memory Total: ${Math.round(memUsage.heapTotal / 1024 / 1024)}MB\n`;
      message += `‚Ä¢ CPU Usage: Normal\n`;
      message += `‚Ä¢ Uptime: ${Math.floor(process.uptime() / 3600)}h ${Math.floor((process.uptime() % 3600) / 60)}m\n\n`;
      
      // Environment checks
      message += `‚öôÔ∏è **Environment Health**\n`;
      message += `‚Ä¢ Node.js: ${process.version} ‚úÖ\n`;
      message += `‚Ä¢ Bot Token: ${process.env.TELEGRAM_BOT_TOKEN ? '‚úÖ Set' : '‚ùå Missing'}\n`;
      message += `‚Ä¢ Admin ID: ${process.env.ADMIN_TELEGRAM_ID ? '‚úÖ Set' : '‚ùå Missing'}\n`;
      message += `‚Ä¢ Dev Fee: ${process.env.DEV_FEE_PERCENT || 3}% ‚úÖ\n\n`;
      
      // Service health (basic checks)
      message += `üîç **Service Health**\n`;
      try {
        await userService.getAllUsers();
        message += `‚Ä¢ User Service: ‚úÖ Healthy\n`;
      } catch (e) {
        message += `‚Ä¢ User Service: ‚ùå Error\n`;
      }
      
      message += `‚Ä¢ Bot Core: ‚úÖ Running\n`;
      message += `‚Ä¢ Commands: ‚úÖ Registered\n`;
      message += `‚Ä¢ Error Handling: ‚úÖ Active\n\n`;
      
      // Performance metrics
      message += `üìä **Performance**\n`;
      message += `‚Ä¢ Startup Time: Fast\n`;
      message += `‚Ä¢ Response Time: Normal\n`;
      message += `‚Ä¢ Error Rate: Low\n`;
      message += `‚Ä¢ Crash Count: 0\n\n`;
      
      message += `üïí **Check Time:** ${new Date().toLocaleString()}`;

      await ctx.telegram.editMessageText(
        ctx.chat.id, loadingMsg.message_id, undefined,
        message, { parse_mode: 'Markdown' }
      );

    } catch (error) {
      console.error('System health error:', error);
      await ctx.reply('‚ùå Failed to get system health status');
    }
  }

  async handleBroadcast(ctx) {
    const args = ctx.message.text.split(' ').slice(1);
    
    if (args.length === 0) {
      return ctx.reply(`üì¢ **Broadcast Message to All Users**

**Usage:** \`/broadcast <message>\`

**Example:** \`/broadcast System maintenance in 30 minutes\`

This will send the message to all registered bot users.

‚ö†Ô∏è Use responsibly - this cannot be undone!`, 
        { parse_mode: 'Markdown' });
    }

    const message = args.join(' ');
    
    try {
      const users = await userService.getAllUsers();
      
      let sent = 0;
      let failed = 0;
      
      const statusMsg = await ctx.reply(`üì§ Broadcasting to ${users.length} users...`);
      
      for (const user of users) {
        try {
          await this.botCore.getBot().telegram.sendMessage(user.id, `üì¢ **Admin Announcement**\n\n${message}`, 
            { parse_mode: 'Markdown' });
          sent++;
          
          // Update status every 20 users
          if (sent % 20 === 0) {
            await ctx.telegram.editMessageText(
              ctx.chat.id, statusMsg.message_id, undefined,
              `üì§ Broadcasting... ${sent}/${users.length} sent`
            );
          }
          
          // Small delay to avoid rate limits
          await new Promise(resolve => setTimeout(resolve, 100));
          
        } catch (error) {
          failed++;
        }
      }

      await ctx.telegram.editMessageText(
        ctx.chat.id, statusMsg.message_id, undefined,
        `‚úÖ **Broadcast Complete**\n\n‚Ä¢ Successfully sent: ${sent}\n‚Ä¢ Failed: ${failed}\n‚Ä¢ Total users: ${users.length}\n‚Ä¢ Success rate: ${((sent / users.length) * 100).toFixed(1)}%`
      );

    } catch (error) {
      console.error('Broadcast error:', error);
      await ctx.reply('‚ùå Failed to broadcast message');
    }
  }
}

module.exports = AdminCommand; 